<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Results - MAB Advisor</title>
    <link href="{{ url_for('static', filename='styles/style2.css') }}" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body>
    <div class="results-container">

        <!-- Header -->
        <header class="results-header">
            <a href="/" class="back-link">&larr; Run New Analysis</a>
            <h1>Algorithm Performance Explorer</h1>
            <p class="subtitle">Drag the slider to explore how Step-to-Reward Conversion Rate 'w' affects the tradeoff and the optimal algorithm</p>
        </header>

        <!-- Interactive Chart Section -->
        <section class="chart-section">
            <div class="chart-wrapper" id="chartWrapper">
                <div class="chart-overlay-topright">
                    Max Reward: <strong id="maxReward">—</strong>
                </div>
                <canvas id="performanceChart"></canvas>
            </div>

            <!-- Use this static fallback when JS is disabled -->
            <noscript>
                <style>#chartWrapper { display: none; } .slider-strip { display: none; }</style>
                {% if plot_path %}
                <div class="chart-wrapper">
                    <img src="{{ url_for('static', filename='performance_plot.png') }}"
                         alt="Algorithm Performance Comparison" style="max-width:100%;">
                </div>
                {% endif %}
            </noscript>

            
            <!-- Slider -->
            <div class="slider-strip">
                <div class="slider-row">
                    <span class="slider-end-label">More Reward</span>
                    <input type="range" id="wSlider" min="0" max="0.06" step="0.003" value="0.03">
                    <span class="slider-end-label">Fewer Steps</span>
                </div>
                <div class="slider-readout">
                    <strong>w = <span id="wValue">0.03</span></strong></div>
            </div>

            <!-- W Range Controls (below slider) -->
            <div class="w-range-config">
                <div class="w-range-inputs">
                    <label>Min w: <input type="number" id="wMin" value="0" min="0" step="0.01"></label>
                    <label>Max w: <input type="number" id="wMax" value="0.06" min="0.01" step="0.01"></label>
                    <button id="updateRange" class="btn btn-secondary">Update Range</button>
                </div>
                <p class="slider-explanation">
                    <strong>Choosing w:</strong> A good starting point is w ≈ 5-10% of the max achievable reward 
                    (shown above). At this level, both reward and experiment length matter. 
                    Beyond ~10% of max reward, increasing w has diminishing returns—you're 
                    already prioritizing shorter experiments.
                </p>
            </div>

            <!-- <p class="chart-hint">
                Curves closer to zero perform better. Bold lines show the optimal configuration for your chosen w.</p> -->


            <details class="chart-help">
                <summary><h3>How to read this chart</h3></summary>
                <div class="chart-help-content">
                    <ul>
                        <li><strong>Y-axis (Relative ECP-reward Loss):</strong> Higher is better.
                            Zero represents the best possible performance at each weight.</li>
                        <li><strong>X-axis (Step-to-Reward Conversion Rate w):</strong> Low w favors 
                            maximizing reward; high w favors reaching statistical power quickly.</li>
                        <li><strong>Dashed lines</strong> show extreme strategies
                            (Pure-TS or Pure-UR) as reference bounds.</li>
                        <li><strong>Bold lines</strong> show the optimal algorithm and
                            parameter for your chosen w.</li>
                        <li>Drag the slider to change w and watch the bold curves and
                            recommendation update instantly.</li>
                    </ul>
                </div>
            </details>
        </section>

        <!-- Dynamic Recommendation Card -->
        <section class="recommendation-card" id="dynamicRec">
            {% if results_summary %}
            <div class="rec-header">
                <h3>Recommended Configuration</h3>
                <span class="rec-badge">for w = <span id="rec-w">8</span></span>
            </div>
            <div class="rec-body">
                <div class="rec-main">
                    <span class="rec-algo" id="rec-algo">&mdash;</span>
                    <span class="rec-param">parameter = <span id="rec-param">&mdash;</span></span>
                </div>
                <div class="metrics-row">
                    <div class="metric">
                        <span class="metric-value" id="rec-steps">&mdash;</span>
                        <span class="metric-label">Expected Steps</span>
                    </div>
                    <div class="metric">
                        <span class="metric-value">{{ results_summary.test_procedure }}</span>
                        <span class="metric-label">Statistical Test</span>
                    </div>
                </div>
            </div>
            {% else %}
            <p>Unable to compute recommendations. Please try again.</p>
            {% endif %}
        </section>

        <!-- noscript: static recommendation fallback -->
        <noscript>
            {% if results_summary %}
            <section class="recommendation-card">
                <h3>Recommended Configuration (Balanced, w=10)</h3>
                <div class="rec-body">
                    <div class="rec-main">
                        <span class="rec-algo">{{ results_summary.best_balanced.algorithm }}</span>
                        <span class="rec-param">parameter = {{ "%.3f"|format(results_summary.best_balanced.parameter) }}</span>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-value">{{ "%.0f"|format(results_summary.best_balanced.n_steps) }}</span>
                            <span class="metric-label">Expected Steps</span>
                        </div>
                    </div>
                </div>
            </section>
            {% endif %}
        </noscript>

        <!-- Collapsible: Your Input Parameters -->
        <section class="inputs-section">
            <details>
                <summary><h3>Your Input Parameters</h3></summary>
                {% if user_inputs %}
                <div class="inputs-grid">
                    {% for label, value in user_inputs.items() %}
                    <div class="input-item">
                        <span class="input-label">{{ label }}:</span>
                        <span class="input-value">{{ value }}</span>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}
            </details>
        </section>

        <!-- Collapsible: Technical Details -->
        <section class="technical-section">
            <details>
                <summary><h3>Technical Details</h3></summary>
                <div class="technical-content">
                    <h4>What the Parameters Mean</h4>
                    <dl>
                        <dt>EpsTS (Epsilon-Thompson Sampling)</dt>
                        <dd>Parameter &epsilon; controls exploration. &epsilon;=0 means pure Thompson Sampling
                        (exploit), &epsilon;=1 means uniform random exploration.</dd>

                        <!-- <dt>TSProbClip</dt> 
                        <dd>Parameter controls minimum selection probability per arm.
                        Higher values ensure more uniform exploration.</dd> 

                        <dt>TSTopUR</dt>
                        <dd>Parameter &delta; defines the "top" threshold. Arms within &delta; of the
                        best estimated arm are selected uniformly.</dd>  -->
                    </dl>

                    <h4>What is w?</h4>
                    <p>The Step-to-Reward Conversion Rate w controls how much you value 
                    cumulative reward during the experiment versus reaching your desired statistical power
                    quickly.  At high w, the objective focuses on minimising the number of
                    steps. At low w, maximising reward matters more. There is no single
                    "correct" w &mdash; it depends on your experimental priorities.</p>

                    <p>As a rule of thumb: if your max achievable reward is R, then setting w between 
                    0.05R and 0.1R provides a meaningful tradeoff. Setting w > R means you're purely 
                    minimizing experiment length with no regard for reward.</p>

                    <h4>What is ECP-Reward?</h4>
                    <p>ECP-reward measures how good an experiment is by balancing two things: how much 
                    reward it earns and how long the experiment runs. Running an experiment longer has 
                    a cost, and the parameter w controls how expensive that cost is. A larger w means
                    that shorter experiments are preferred.</p>

                    <p>When you choose a value of w, we first find the algorithm that performs best at 
                    that value. That algorithm is treated as the optimal choice for your selected w.</p>

                    <p>The curve then shows how that same algorithm performs across all values of w. The 
                    y-axis shows relative ECP loss, where 0 means the algorithm is optimal at that w, 
                    and higher values mean it performs worse than the best possible choice at that w.</p>

                    <p>This plot helps you understand how sensitive your algorithm choice is to the 
                    value of w, and how much performance you might lose if w is different from what you 
                    expected.</p>

                    <p>In addition to the selected algorithm, we also plot Thompson Sampling (TS) and 
                    Uniform Randomization (UR) as reference strategies.</p>

                    <p>These reference curves are shown for comparison. They help illustrate how the 
                    selected algorithm performs relative to two commonly used baselines: one that 
                    prioritize for reward (TS), and one that assigns actions uniformly at random for 
                    balanced exploration (UR).</p>

                    <h4>Interpreting Results</h4>
                    <p>The recommended parameter balances the exploration-exploitation tradeoff
                    for your specific setting. Lower parameters generally favour exploitation
                    (using what we know), while higher parameters favour exploration
                    (gathering more information).</p>

                    {% if results_summary %}
                    <p><strong>Analysis Summary:</strong> We tested
                    {{ results_summary.n_algorithms_tested }} algorithm(s) with
                    {{ results_summary.n_parameter_values }} parameter values each.</p>
                    {% endif %}
                </div>
            </details>
        </section>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <a href="/" class="btn btn-primary">Run New Analysis</a>
            <button onclick="window.print()" class="btn btn-secondary">Print / Save Results</button>
        </div>
    </div>

    <!-- Chart logic -->
    <script>
    (function () {
        /* ── raw data injected from Flask ── */
        const rawData = {{ chart_data_json | safe }};
        if (!rawData || rawData.length === 0) return;

        const W_MIN = 0, W_MAX = 0.06;
        const numSteps = 20;
        let wValues = [];
        for (let i = 0; i <= numSteps; i++) {
            wValues.push(parseFloat((W_MIN + (W_MAX - W_MIN) * (i / numSteps)).toFixed(4)));
        }

        /* ── group rows by algorithm ── */
        const algorithms = {};
        rawData.forEach(row => {
            if (!algorithms[row.algo_name]) algorithms[row.algo_name] = [];
            algorithms[row.algo_name].push(row);
        });
        const algoNames = Object.keys(algorithms);

        /* ── objective function (mirrors main.py compute_objective) ── */
        function computeObjective(nStep, reward, w) {
            if (nStep <= 1) return nStep;
            return reward - w * Math.log(nStep);
        }

        /* ── baseline: best objective per w across ALL rows ── */
        const baseline = {};
        wValues.forEach(w => {
            let max = -Infinity;
            rawData.forEach(row => {
                const obj = computeObjective(row.n_step, row.regret_per_step, w);
                if (obj > max) max = obj;
            });
            baseline[w] = max;
        });

        /* ── compute relative curve for a single row ── */
        function relativeCurve(row) {
            return wValues.map(w => {
                const raw = computeObjective(row.n_step, row.regret_per_step, w);
                return raw - baseline[w];
            });
        }

        /* ── find best row for an algorithm at a given w ── */
        function bestRowForW(algoRows, w) {
            let best = null, bestObj = -Infinity;
            algoRows.forEach(row => {
                const obj = computeObjective(row.n_step, row.regret_per_step, w);
                if (obj > bestObj) { bestObj = obj; best = row; }
            });
            return best;
        }

        /* ── colour helpers ── */
        const palette = ['#007BFF', '#dc3545', '#28a745', '#fd7e14', '#6f42c1'];
        function hexToRGBA(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
        }

        /* ── build fixed datasets (param=0, param=1) ── */
        const fixedDatasets = [];
        algoNames.forEach((name, i) => {
            const color = palette[i % palette.length];
            const faded = hexToRGBA(color, 0.5);
            const rows = algorithms[name];

            // param=0 curve — GREEN, dashed
            const row0 = rows.find(r => r.algo_param === 0.0);
            if (row0) {
                fixedDatasets.push({
                    label: 'Pure-TS', //name + ' \u2014 Always Exploit'
                    data: relativeCurve(row0),
                    borderColor: '#28a745',        // green
                    backgroundColor: '#28a745',
                    borderDash: [6, 4],
                    borderWidth: 2.5,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    tension: 0.2
                });
            }
            // param=1 curve — RED, dashed
            const row1 = rows.find(r => r.algo_param === 1.0);
            if (row1) {
                fixedDatasets.push({
                    label: 'Pure-UR', //name + ' \u2014 Always Explore',
                    data: relativeCurve(row1),
                    borderColor: '#dc3545',        // red
                    backgroundColor: '#dc3545',
                    borderDash: [6, 4],
                    borderWidth: 2.5,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    tension: 0.2
                });
            }
        });

        /* ── dynamic (optimal-for-w) datasets — BLUE, bold ── */
        const dynamicStartIdx = fixedDatasets.length;
        const dynamicDatasets = algoNames.map((name, i) => ({
            label: name + ' \u2014 Optimal',
            data: [],
            borderColor: '#007BFF',            // blue
            backgroundColor: '#007BFF',
            borderWidth: 3.5,
            pointRadius: 5,
            pointHoverRadius: 8,
            tension: 0.2
        }));

        /* ── baseline dataset (y = 0) ── */
        const baselineDataset = {
            label: 'Baseline (best possible)',
            data: wValues.map(() => 0),
            borderColor: '#aaa',
            borderDash: [5, 5],
            borderWidth: 1,
            pointRadius: 0
        };

        const allDatasets = [...fixedDatasets, ...dynamicDatasets, baselineDataset];

        /* ── create chart ── */
        const ctx = document.getElementById('performanceChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: { labels: wValues, datasets: allDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 1.7,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    title: {
                        display: true,
                        text: 'Algorithm Performance Across Step-to-Reward Conversion Rate (w)',
                        font: { size: 20, weight: 'bold' },
                        padding: { bottom: 16 }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 18,
                            font: { size: 14 }
                        }
                    },
                    tooltip: {
                        titleFont: { size: 14 },
                        bodyFont: { size: 14 },
                        callbacks: {
                            label: function (ctx) {
                                return ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(1);
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: ' Step-to-Reward Conversion Rate (w)', font: { size: 16 } },
                        ticks: { font: { size: 14 } },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    },
                    y: {
                        title: { display: true, text: 'Relative ECP-reward Loss', font: { size: 16 } },
                        ticks: { font: { size: 14 } },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    }
                }
            }
        });

        /* ── update chart + recommendation for a given w ── */
        function updateForW(w) {
            let bestAlgo = null, bestObj = -Infinity, bestRow = null;

            algoNames.forEach((name, i) => {
                const row = bestRowForW(algorithms[name], w);
                const dsIdx = dynamicStartIdx + i;

                chart.data.datasets[dsIdx].data = relativeCurve(row);
                chart.data.datasets[dsIdx].label =
                    name + ' \u2014 Optimal for w=' + w +
                    ' (param=' + row.algo_param.toFixed(2) + ')';

                const obj = computeObjective(row.n_step, row.regret_per_step, w);
                if (obj > bestObj) {
                    bestObj = obj;
                    bestAlgo = name;
                    bestRow = row;
                }
            });

            chart.update('none');   /* skip animation for smooth slider feel */

            /* update recommendation card */
            document.getElementById('rec-w').textContent     = w;
            document.getElementById('rec-algo').textContent   = bestAlgo;
            document.getElementById('rec-param').textContent  = bestRow.algo_param.toFixed(3);
            document.getElementById('rec-steps').textContent  = Math.round(bestRow.n_step);
            document.getElementById('wValue').textContent     = w;
        }

        /* ── initialise ── */
        var defaultW = 0.03;
        document.getElementById('wSlider').value = defaultW;
        updateForW(defaultW);

        /* ── slider event ── */
        document.getElementById('wSlider').addEventListener('input', function (e) {
            updateForW(parseFloat(e.target.value));
        });

        // Compute max reward (from pure-TS / param=0 row)
        const pureTS = rawData.find(r => r.algo_param === 0.0);
        const maxReward = pureTS ? pureTS.regret_per_step : null;
        if (maxReward) {
            document.getElementById('maxReward').textContent = maxReward.toFixed(3);
        }

        // Function to rebuild chart with new w range
        function updateWRange() {
            const wMin = parseFloat(document.getElementById('wMin').value);
            const wMax = parseFloat(document.getElementById('wMax').value);
            
            if (wMin >= wMax || wMin < 0) {
                alert('Invalid range: min must be less than max and non-negative');
                return;
            }
            
            // 21 discrete values (ensures we include both endpoints)
            const numSteps = 20;
            const newWValues = [];
            for (let i = 0; i <= numSteps; i++) {
                const w = wMin + (wMax - wMin) * (i / numSteps);
                newWValues.push(parseFloat(w.toFixed(4)));
            }
            const step = (wMax - wMin) / numSteps;
            
            // Update slider
            const slider = document.getElementById('wSlider');
            slider.min = wMin;
            slider.max = wMax;
            slider.step = step;
            slider.value = (wMin + wMax) / 2;
            
            // Update global wValues and chart x-axis
            wValues = newWValues;
            chart.data.labels = wValues;
            
            // Recompute baseline for new w values
            wValues.forEach(w => {
                let max = -Infinity;
                rawData.forEach(row => {
                    const obj = computeObjective(row.n_step, row.regret_per_step, w);
                    if (obj > max) max = obj;
                });
                baseline[w] = max;
            });
            
            // Update fixed datasets (Pure-TS and Pure-UR)
            fixedDatasets.forEach((ds, idx) => {
                let row = null;
                if (ds.label === 'Pure-TS') {
                    row = rawData.find(r => r.algo_param === 0.0);
                } else if (ds.label === 'Pure-UR') {
                    row = rawData.find(r => r.algo_param === 1.0);
                }
                if (row) {
                    chart.data.datasets[idx].data = wValues.map(w => {
                        const raw = computeObjective(row.n_step, row.regret_per_step, w);
                        return raw - baseline[w];
                    });
                }
            });
            
            // Update dynamic datasets (optimal curves)
            algoNames.forEach((name, i) => {
                const dsIdx = dynamicStartIdx + i;
                const midW = (wMin + wMax) / 2;
                const row = bestRowForW(algorithms[name], midW);
                chart.data.datasets[dsIdx].data = wValues.map(w => {
                    const raw = computeObjective(row.n_step, row.regret_per_step, w);
                    return raw - baseline[w];
                });
            });
            
            // Update baseline line (y = 0)
            const baselineIdx = allDatasets.length - 1;
            chart.data.datasets[baselineIdx].data = wValues.map(() => 0);
            
            // Refresh chart and update recommendation
            chart.update();
            updateForW(parseFloat(slider.value));
        }


        document.getElementById('updateRange').addEventListener('click', updateWRange);    

    })();
    </script>
</body>
</html>